#!/usr/bin/env ruby

require 'rubygems'

require 'csv'
require 'etc'
require 'httpclient'
require 'open-uri'
require 'thor'

# NOTE You'll need to setup Twitter app stuff for the `t` command. See the
# documentation for the `t` command.

FILTERS = [
  /twitter.*status.*photo/
]

class CLI < Thor
  RCFILENAME = File.join(Etc.getpwuid.dir, '.twlinksrc')

  default_command :get

  desc 'get', 'get all links in tweets since last recorded ID'
  def get
    process_links(get_timeline(build_command))
  end

  desc 'reset', 'reset (remove) the last ID recorded'
  def reset
    File.truncate(RCFILENAME, 0) if File.exist?(RCFILENAME)
  end

  private

  # FIXME previous_id is off by one after a reset.
  def build_command
    command = "command t timeline -c"
    previous_id = File.exist?(RCFILENAME) ? File.read(RCFILENAME).to_i : 0
    command << " -s #{ (previous_id + 1) }" if previous_id > 0
    # command << " 2> /dev/null"
    command
  end

  def get_timeline(command)
    timeline = CSV.parse(%x{#{ command }})
    timeline.shift
    timeline
  end

  def process_links(timeline)
    if timeline.length > 0
      save_new_id(get_new_id(timeline))

      timeline.each do |tweet|
        link = get_link(tweet)
        if link
          redirect_link = get_redirect_link(link)
          unless filtered?(redirect_link)
            printf("%-20s => %s\n", get_screename(tweet), redirect_link)
          end
        end
      end
    end
  end

  def get_new_id(timeline)
    timeline.first(2).last.first
  end

  def save_new_id(new_id)
    File.open(RCFILENAME, 'w') { |f| f.write("#{ new_id }\n") }
  end

  def get_link(tweet)
    /(http\S+)/.match(tweet.last).to_a.first
  end

  def get_screename(tweet)
    tweet[-2]
  end

  def get_redirect_link(link)
    HTTPClient.new.head(link).header['Location'].first # or use #get
  rescue => error
    "[error parsing redirect on #{ link }: #{ error }]"
  end

  def filtered?(link)
    FILTERS.any? { |filter| filter.match(link) }
  end
end

CLI.start(ARGV) if $0 == __FILE__
