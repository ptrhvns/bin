#!/usr/bin/env ruby

module Enumerable
  def sum
    return 0 unless length > 0
    self.reduce(:+)
  end

  def mean
    return 0 unless length > 0
    sum / length.to_f
  end

  def median
    return 0 unless length > 0
    n = length
    values = sort

    if n.odd?
      return values[(n + 1) / 2]
    else
      return (values[n / 2].to_i + values[(n / 2) + 1].to_i) / 2
    end
  end

  def sample_variance
    return 0 unless length > 0
    m = mean
    sum = inject(0) {|accum, i| accum + (i - m) ** 2 }
    return 0 unless (length - 1) > 0
    sum / (length - 1).to_f
  end

  def standard_deviation
    return 0 unless length > 0
    Math.sqrt(sample_variance)
  end

  def range
    return '0' unless length > 0
    values = sort
    "#{ values.first } - #{ values.last }"
  end
end

if ARGV.first == '-h'
  puts "usage: git #{ File.basename($0).gsub(/git-/, '') } [author]"
  puts "\nPrints statistics about lines of code added (insertions) per day."
  exit
end

author = ARGV.first
data = {}
date = ''

%x(git log --numstat --format="%ad" --author="#{ author }").each_line do |line|
  case line
  when /^([MTWFS]\S+\s+\S+\s+\S+)/
    date = $1
    data[date] = :none # Ensure things like merge commits are omitted.
  when /^(\d+)/
    insertions = $1.to_i
    old_value = (:none == data[date]) ? 0 : data[date]
    data[date] = old_value + insertions
  end
end

values = data.values.reject { |v| :none == v}

puts <<END
lines of code / day (#{ author ? author : 'all authors' })
  median             => #{ values.median.to_f.round(1) }
  mean               => #{ values.mean.to_f.round(1) }
  standard deviation => #{ values.standard_deviation.to_f.round(1) }
  range              => #{ values.range }

total insertions     => #{ values.sum}
END
