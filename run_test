#!/usr/bin/env python

import json
import pathlib
import sys
from argparse import ArgumentParser
from itertools import zip_longest
from os import environ, path
from re import search, sub

sys.path.append(path.join(environ["HOME"], "lib"))

from output import die
from shell import cd, run


class TestingStrategyNotFound(Exception):
    def __init__(self, filename):
        super().__init__(f"testing strategy not found for {filename}")


def process_args():
    parser = ArgumentParser(description="Detect how to run tests, and run them.")
    parser.add_argument(
        "file_name", help="name of the file from which this command was run"
    )
    parser.add_argument(
        "-t",
        default=None,
        dest="target",
        help="which test(s) in the file name to run (default is all)",
    )
    return parser.parse_args()


def find_up_tree(directory, file):
    root_visited = False
    while True:
        if root_visited:
            return None

        full_path = path.join(directory, file)

        if path.exists(full_path):
            return full_path
        else:
            directory, _ = path.split(directory)

            if directory == "/":
                root_visited = True


def file_contains(path, text):
    with open(path) as f:
        return True if text in f.read() else False


def rspec(args):
    line = f":{args.target}" if args.target else ""

    if path.exists("./bin/rspec"):
        run(
            ["time", "./bin/rspec", "-f", "d", f"{args.file_name}{line}"],
            verbose=False,
        )
    elif path.exists("./server/bin/rspec"):
        with cd("server"):
            file_name = sub("server/", "", args.file_name, count=1)
            run(
                ["time", "./bin/rspec", "-f", "d", f"{file_name}{line}"],
                verbose=False,
            )
    elif path.exists("./server"):
        with cd("server"):
            file_name = sub("server/", "", args.file_name, count=1)
            run(
                [
                    "time",
                    "bundle",
                    "exec",
                    "rspec",
                    "-f",
                    "d",
                    f"{file_name}{line}",
                ],
                verbose=False,
            )
    else:
        run(
            ["time", "bundle", "exec", "rspec", "-f", "d", f"{args.file_name}{line}"],
            verbose=False,
        )


def javascript(args):
    abs_file_name = path.abspath(args.file_name)
    package_path = find_up_tree(path.dirname(abs_file_name), "package.json")

    if not package_path:
        raise TestingStrategyNotFound(args.file_name)

    with cd(path.dirname(package_path)):
        with open(package_path) as package_file:
            scripts = json.load(package_file)["scripts"]
            target = None

            if "/e2e/" in abs_file_name:
                target = scripts.get("test:e2e")
            elif "/unit/" in abs_file_name:
                target = scripts.get("test:unit")
            elif "mocha" in abs_file_name:
                target = scripts.get("test:mocha")
            else:
                target = scripts.get("test")

            if not target:
                raise TestingStrategyNotFound(args.file_name)

            cmd = ["time", "npx"] + target.split()[0:-1] + [abs_file_name]
            run(cmd, verbose=False)


def rake(args):
    run(
        ["bundle", "exec", "rake", "test", f"TEST={args.file_name}"],
        verbose=False,
    )


def find_requirements_with_pytest(dirname):
    requirements_filenames = ["requirements.development.txt", "requirements.txt"]
    for f in requirements_filenames:
        path = find_up_tree(dirname, f)
        if path and file_contains(path, "pytest"):
            return path


def python(args):
    file_name_path = path.abspath(args.file_name)
    dirname = path.dirname(file_name_path)

    manage_path = find_up_tree(dirname, "manage.py")
    if manage_path:
        file_name_path_root = path.splitext(file_name_path)[0]
        file_name_path_parts = pathlib.Path(file_name_path_root).parts
        manage_dirname = path.dirname(manage_path)
        manage_dirname_parts = pathlib.Path(manage_dirname).parts
        label = ".".join(
            [
                p1
                for p1, p2 in zip_longest(file_name_path_parts, manage_dirname_parts)
                if p1 != p2
            ]
        )
        cmd = ["python", "-Wa", manage_path, "test", label, "--keepdb", "--failfast"]
        if args.target:
            cmd.append("--tag=only")
        run(cmd, verbose=False)
        return

    requirements_path = find_requirements_with_pytest(dirname)
    if requirements_path:
        with cd(path.dirname(requirements_path)):
            cmd = ["pytest", "-q", file_name_path]
            if args.target:
                cmd.extend(["-m", "focus"])
            run(cmd, verbose=False)
        return

    raise TestingStrategyNotFound(args.file_name)


if __name__ == "__main__":
    args = process_args()

    try:
        if search(r"\.jsx?$", args.file_name):
            javascript(args)
        elif search(r"test\.rb$", args.file_name):
            rake(args)
        elif search(r"spec\.rb$", args.file_name):
            rspec(args)
        elif search(r"\.py$", args.file_name):
            python(args)
        else:
            raise TestingStrategyNotFound(args.file_name)
    except TestingStrategyNotFound as e:
        die(str(e))
