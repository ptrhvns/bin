#!/usr/bin/env ruby

require 'date'
require 'optparse'

class Statistics
  attr_reader :numbers

  def initialize(numbers)
    @numbers = numbers
  end

  def sum
    return 0 if numbers.empty?
    numbers.reduce(:+)
  end

  def mean
    return 0 if numbers.empty?
    numbers.sum / numbers.length.to_f
  end

  def median
    return 0 if numbers.empty?
    n = numbers.length
    values = numbers.sort
    return values[(n + 1) / 2] if n.odd?
    (values[n / 2].to_i + values[(n / 2) + 1].to_i) / 2
  end

  def sample_variance
    return 0 if numbers.empty?
    m = mean
    sum = numbers.inject(0) { |accum, i| accum + (i - m)**2 }
    return 0 unless (numbers.length - 1).positive?
    sum / (numbers.length - 1).to_f
  end

  def standard_deviation
    return 0 if numbers.empty?
    Math.sqrt(sample_variance)
  end

  def range
    return '0' if numbers.empty?
    values = numbers.sort
    "#{values.first} - #{values.last}"
  end
end

def parse_args
  git_command = File.basename($PROGRAM_NAME).gsub(/git-/, '')

  {}.tap do |options|
    options[:author] = ''
    options[:days] = 7
    options[:verbose] = false

    OptionParser.new do |op|
      op.banner = "Usage: git #{git_command} [options]"
      op.separator ''
      op.separator 'Analyze git logs to find total insertions and deletions.'
      op.separator ''
      op.separator 'Options:'

      op.on(
        '-a AUTHOR',
        '--author AUTHOR',
        'analyze only for AUTHOR (default: all)'
      ) do |author|
        options[:author] = author
      end

      op.on(
        '-d DAYS',
        '--days DAYS',
        'analyze only after DAYS days ago (default: 7)'
      ) do |days|
        options[:days] = days.to_i
      end

      op.on(
        '-v',
        '--verbose',
        'display verbose output (show data for each day)'
      ) do
        options[:verbose] = true
      end
    end.parse!
  end
end

def initialize_data(options)
  days = (0..options[:days]).map do |d|
    (Date.today - d).strftime('%a %b %-d %Y')
  end

  Hash.new.tap { |data| days.each { |day| data[day] = 0 } }
end

def main
  options = parse_args

  command = [
    'git',
    'log',
    %(--after="#{options[:days]} days ago"),
    %(--author="#{options[:author]}"),
    '--format="%ad"',
    '--numstat'
  ].join(' ')

  insertions = initialize_data(options)
  deletions = initialize_data(options)
  date = ''

  `#{command}`.each_line do |line|
    case line
    when /^([MTWFS]\S+\s+\S+\s+\S+)\s+\S+\s+(\S+)/
      dow_month_day = Regexp.last_match(1)
      year = Regexp.last_match(2)
      date= "#{dow_month_day} #{year}"
    when /^(\d+)\s+(\d+)/
      new_insertions = Regexp.last_match(1).to_i
      new_deletions = Regexp.last_match(2).to_i
      insertions[date] = insertions[date] + new_insertions
      deletions[date] = deletions[date] + new_deletions
    end
  end

  if options[:verbose]
    puts "data: insertions: #{insertions.inspect}\n\n"
    puts "data: deletions: #{deletions.inspect}\n\n"
  end

  insertion_statistics = Statistics.new(insertions.values)
  deletion_statistics = Statistics.new(deletions.values)
  net_values = insertions.values.zip(deletions.values).map{ |i, d| i - d }
  net_statistics = Statistics.new(net_values)

  author = options[:author].empty? ? 'all authors' : options[:author]

  puts <<~OUTPUT
    From #{options[:days]} day(s) ago to now, the impact for <#{author}> was:

    insertions:
      mean               => #{insertion_statistics.mean.to_f.round(1)}
      median             => #{insertion_statistics.median.to_f.round(1)}
      range              => #{insertion_statistics.range}
      standard deviation => #{insertion_statistics.standard_deviation.to_f.round(1)}
      sum                => #{insertion_statistics.sum}

    deletions:
      mean               => #{deletion_statistics.mean.to_f.round(1)}
      median             => #{deletion_statistics.median.to_f.round(1)}
      range              => #{deletion_statistics.range}
      standard deviation => #{deletion_statistics.standard_deviation.to_f.round(1)}
      sum                => #{deletion_statistics.sum}

    net (insertions - deletions):
      mean               => #{net_statistics.mean.to_f.round(1)}
      median             => #{net_statistics.median.to_f.round(1)}
      range              => #{net_statistics.range}
      standard deviation => #{net_statistics.standard_deviation.to_f.round(1)}
      sum                => #{net_statistics.sum}
  OUTPUT
end

main if $PROGRAM_NAME == __FILE__
