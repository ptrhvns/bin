#!/usr/bin/env ruby

require "optparse"
require "set"
require "stringio"
require "ostruct"

$verbose = false

CPATH='-o ControlPath=/tmp/.ssh_%r@%h:%p'

CLEANFILES = %w{
  .aliases .profile .login .sh_history local.cshrc local.login local.profile
  .mailrc bin/diskinfo .pythonrc bin/stdin_as_file .bash_completions .screenrc
}

HOST = '/usr/bin/host'
SCP = '/usr/bin/scp'
SSH = '/usr/bin/ssh'
PREFIX = '>>>'
ENVVERFILE = File.join(ENV["HOME"], "etc", "env_version")

ENVFILES = [
  ["~/.ssh/id_dsa.pub",           ".ssh/authorized_keys",  644],
  ["~/src/rcfiles/bash_profile",  ".bash_profile",         644],
  ["~/src/rcfiles/bashrc",        ".bashrc",               644],
  ["~/src/rcfiles/vimrc",         ".vimrc",                644],
  ["~/src/rcfiles/inputrc",       ".inputrc",              644],
  ["~/bin/ipcalc",                "bin/ipcalc",            755],
  ["~/bin/ifns",                  "bin/ifns",              755],
  ["~/etc/env_version",           ".env_version",          644]
]

def say(msg)
  puts "#{PREFIX} #{msg}" if $verbose
end

def parse_arguments
  parser = OptionParser.new

  parser.banner = <<-END
usage: #{File.basename($0)} [options] [arguments]

This program updates the remote shell environment before logging in.
  END

  parser.separator ""
  parser.separator "options:"
  opts = {}
  opts[:clean] = false
  opts[:force] = false
  opts[:port] = "22"
  opts[:user] = ENV['USER']

  parser.on("-c", "--clean", "clean up remote environment") do
    opts[:clean] = true
  end

  parser.on("-f", "--force", "force an update of remote environment") do
    opts[:force] = true
  end

  parser.on("-h", "--help", "show this message and exit") do
    puts parser
    exit
  end

  parser.on("-p", "--port PORT", "login remotely on PORT") do |port|
    opts[:port] = port
  end

  parser.on("-u", "--user USER", "login remotely as USER") do |user|
    opts[:user] = user
  end

  parser.on("-v", "--verbose", "show verbose output") do
    $verbose = true
  end

  parser.parse! ARGV
  opts
end

def verify_dns_lookup(opts)
  say "verifying hostname"

  system("#{HOST} #{opts[:host]} &> /dev/null")
  raise "DNS lookup failed on address: #{opts[:host]}" if 0 != $?
end

def ssh(opts, code=0)
  s = OpenStruct.new
  yield s
  command = "#{SSH} #{CPATH} -p #{opts[:port]} -l #{opts[:user]}"

  append = proc do |args|
    if args
      case args
      when Array then args.each {|a| command << " #{a}"}
      when String then command << " #{args}"
      end
    end
  end

  append.call s.args
  append.call opts[:host]
  append.call s.command
  output = %x{#{command}}
  raise "ssh failed (#{command})" if code != $?
  output
end

def scp(opts, lfile, rfile, mode)
  system(SCP, CPATH, "-P", opts[:port], File.expand_path(lfile),
         "#{opts[:user]}@#{opts[:host]}:#{rfile}")
  raise "scp failed (#{lfile} -> #{rfile})" if $? != 0
  ssh(opts) {|s| s.command = %W{chmod #{mode.to_s} #{rfile}}}
end

def ssh_master_running?(opts)
  say "checking for ssh master"

  begin
    ssh(opts) do |s|
      s.args = %w{-O check}
      s.command = %w{&> /dev/null}
    end
  rescue
    return false
  end
  true
end

def start_ssh_master(opts)
  say "starting ssh master"
  return if ssh_master_running?(opts)
  ssh(opts) do |s|
    s.args = %w{-MNf}
    s.command = %w{&> /dev/null}
  end
end

def stop_ssh_master(opts)
  say "stopping ssh master"
  return unless ssh_master_running?(opts)
  ssh(opts) do |s|
    s.args = %w{-O exit}
    s.command = %w{&> /dev/null}
  end
end

def remote_env_current?(opts)
  say "checking remote environment version"
  rver = lver = 0
  open(ENVVERFILE) {|io| lver = io.readline.to_i }

  begin
    rver = ssh(opts) {|s| s.command = %w{cat .env_version 2>/dev/null}}.to_i
  rescue
    nil
  end

  lver > rver ? false : true
end

def clean_remote_env(opts)
  say "cleaning up remote environment"
  ssh(opts) {|s| s.command = %W{rm -rf #{CLEANFILES.join " "}}}
end

def update_remote_env(opts)
  say "updating remote environment"
  ssh(opts) {|s| s.command = %w{mkdir -p .ssh bin tmp}}
  ENVFILES.each {|e| scp opts, *e}
end

def main
  Signal.trap "INT", "EXIT"
  opts = parse_arguments
  opts[:host] = ARGV.shift or raise "no host specified"

  say "host #{opts[:host]}, remote user #{opts[:user]}"

  verify_dns_lookup opts
  start_ssh_master opts
  clean_remote_env(opts) if opts[:clean]
  update_remote_env(opts) if opts[:force] or not remote_env_current?(opts)
  stop_ssh_master opts

  say "execing ssh"
  exec SSH, "-Xp", opts[:port], "-l", opts[:user], opts[:host]
  raise "ssh failed (exec)"
rescue
  STDERR.puts "#{PREFIX} ERROR: #{$!}"
  exit 1
end

main if $0 == __FILE__
